타입
-어떠한 값을 담을 수 있는 형태(종류)이다. 크게 기초 타입과 참조 타입으로 나누어져 있다.

기초 타입
-기초 타입(기본 타입, 원시 타입, prmitive type)은 해당 타입의 변수 값이 리터럴(literal)이고 메모리의 스택(stack)영역에 값이 직접 할당되는 타입
-정수형
	* byte : (1 byte) - 128 이상 127이하의 정수
	* short : (2 bytes) -32,768 이상 32,767 이하의 정수
	* int : (4 bytes) -2,147,483,648 이상 2,147,483,647 이하의 정수
	* long : (8 bytes) -9,223,372,036,854,775,808 이상 9,223,372,036,854,775,807 이하의 정수. 리터럴 숫자 끝에 L을 붙임으로써 long 타입의 숫자임을 명시적으로 표현할 수 있다. 가령 314L은 long타입인 314이다.
	*보다 작은 타입의 값을 보다 큰 타입에 할당하는 것은 가능하지만, 보다 큰 타입의 값을 보다 작은 타입에 할당하는 것은 (강제 형변환을 통하지 않으면) 허용되지 않는다.
	*별도의 명시가 없는 정수 표기는 모두 int 타입으로 간주. 단, 아래의 경우는 예외로 한다.
	    - -128 이상 127 이하의 정수 리터럴을 byte 타입의 변수에 할당하는 경우
	    - -32,768 이상 32,767 이하의 정수 리터럴을 short 타입의 변수에 할당하는 경우
-실수형
	*float : (4 bytes) 1.4E-45 이상 3.4E+38 이하의 실수. 리터럴 숫자 끝에 f를 붙임으로써 float 타입의 숫자임을 명시적으로 표현할 수 있다. 가령 3.14f는 float타입인 3.14이다.
	*double : (8 bytes) 4.9E-324 이상 1.79E+308 이하의 실수. 리터럴 숫자 끝에 d를 붙임으로써 double 타입의 숫자임을 명시적으로 표현할 수 있다. 가령 3.14d는 double타입인 3.14이다.
-문자형
	* char : (2 bytes) 문자 하나를 담기 위해 사용하는 타입. 특수문자 ( ' )를 사용. 역슬래쉬(\)를 활용하여 특수한 문자를 할당할 수 있다. 가령, 개행자는 \n이고, 공란은 \0과 같다. 문자형 타입의 값은 비어있을 수 없음에 유의
-논리형
	*boolean : (1 byte) true와 false를 가진다.

참조 타입
-reference type 해당 타입의 변수 값이 리터럴이지 않고 (문자열 string 예외), 메모리의 스택(stack) 영역에는 힙(heap)의 주소가, 힙 영역에는 실질적인 값(혹은 딕셔너리)이 저장된다.
-기초 타입을 제외한 나머지 모든 타입은 참조 타입
-참조 타입은 new 키워드를 통해 객체화(instantiation)하여 구현하고, 이 값을 객체라고 한다. 이 객체의 메모리 크기는 가변적
-대표적인 참조 타입으로 문자열(String)이 있다. 문자열은 객체화 과정(new)을 생략하고 ( " )특수기호를 통해 리터럴처럼 사용할 수 있다.

------------------------------------------------------------------------------

형변환


------------------------------------------------------------------------------

변수
-variable 타입과 이름을 가지고 타입에 부합하는 값을 할당하여 활용하기 위해 사용. 종류는 지역 변수와 멤버 변수, 매개 변수 등으로 나눌 수 있다.

지역 변수
-명명법 : 카멜 케이스
-local variable는 method안에 존재하는 변수
-지역 변수에 값이 할당된적이 없다면, 값 할당을 제외한 접근이 제한된다.
-선언 방식은 아래와 같다
	[타입] [이름];

	   *혹은 선언과 동시에 값을 초기화하기 위해 아래와 같이 작성
	[타입] [이름] = [값];

	   * 가령, 타입이 정수형(int)이고 이름이 age이며, 초기 값이 25인 변수의 선언은 int age = 25;

맴버 변수
-member variable 클래스나 인터페이스 등의 구성 요소가 직접 가지는 변수
-상수가 아닌 멤버 변수에 값을 할당한적이 없다면, 자동으로 기본 값이 할당
	*정수 및 실수 들 숫자 기초 타입 : 0
	*문자 기초 타입 : \0
	*논리 기초 타입 : false
	*모든 참조 타입 : null
	*상수인 멤버 변수의 값은 반드시 직접 할당하거나, 생성자를 통해 초기화하여야 한다. 단, 하나의 멤버 변수에 대해 두 방식을 동시에 사용할 수는 없다.

매개 변수
-parameter 메서드 호출시, 호출자가 전달해 주는 인자(Argument)를 전달 받기 위해 사용하는 변수

------------------------------------------------------------------------------

상수(읽기 전용)
-명명법 : 카멜 케이스
-읽기 전용 변수는 편의상 상수라고 많이 부르며 final 키워드를 통해 변수의 (스택)값이 한번 할당된 이후로 변할 수 없음을 지정
-final 키워드를 사용하였다 하더라도 참고 타입의 객체가 가지는 힙 영역의 내용에 대한 불변성(immutability)이 보장되는 것은 아님으로 엄밀히 말하면 상수(constant)라고 말하면 안 되나, 편의상 상수라고 많이 얘기한다.
-정적이면서 읽기 전용(static final)이며 리터럴(모든 기초 타입 및 String)인 멤버 변수에 한해 대문자 스네이크 케이스 명명법을 사용
-선언 방식은 아래와 같다
	final [타입] [이름] = [값];

	   *지역 변수는 읽기 전용으로 지정하여도 값 초기화를 할 필요는 없기 때문에 아래와 같이 선언할 수 있다.
	final [타입] [이름];