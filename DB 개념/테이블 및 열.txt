테이블
-실제 데이터(레코드)를 담기 위해 존재
-반드시 스키마에 속해 있어야 한다.
-명명법: 스네이크 케이스, 복수형

-----------------------------------------

생성하기
-테이블을 생성하기 위해 아래 쿼리를 실행
	CREATE TABLE `스키마 이름`.`테이블 이름`
	(
	   [열 구조, . . .],
	   [제약 조건 구조, . . .]
	);


기본키 제약 조건(Primary Key Constraint)
-기본키가 되는 한 개 이상의 열(들)은 해당 테이블의 기준이 되는 열(들)을 의미
-기본키가 지정되는 열(들)이 가지는 값에 대해서 레코드(들)는 중복되는 값을 가질 수 없다.
-하나의 테이블은 기본키를 가지지 않거나 하나의 기본키만 가질 수 있다. 단, 이는 하나의 열만 기본키여야함을 의미하지는 않음에 유의
-기본키의 대상이 되는 열은 NULL일 수 없음으로, 해당 열은 NOT NULL이어야 한다.
-기본키를 선언하려면 아래와 같이 제약 조건 구조를 작성한다.
	CONSTRAINT PRIMARY KEY ([`열 이름`, . . . ])

유니크 제약 조건(Unique Key Constraint)
-유니크로 지정된 열이 가지는 값은 중복될 수 없다.
-값이 중복될 수 없다는 부분은 기본키와 같으나, 유니크는 테이블에서 대표성을 띄지 않는다는 점과, 하나의 테이블이 여러개의 유니크를 가질 수 없다는 점 등이 다르다.
-추가로, 기본키는 NULL값을 허용하지 않지만, 유니크는 NULL값을 허용한다. 또한, NULL값에 대해서는 중복 검사를 실시하지 않는다.
-유니크 제약 조건을 선언하려면 아래와 같이 제약 조건 구조를 작성한다.
	CONSTRAINT UNIQUE ([`열 이름`, . . . ])

외래키 제약 조건(Foreign Key Constraint)
-외래키 제약 조건이 적용 되는 열이 가지는 레코드의 값을 참조 대상(Referencing) 테이블의 열이 가지는 레코드의 값으로 제한하기 위해 사용하는 제약 조건
-참조 대상이 되는 열은 기본키이거나 유니크여야 한다.
-외래키를 적용하고 있는 열과 참조 대상인 열의 데이터 타입은 호환되어야 한다. (같아야 한다.)
-외래키를 선언하려면 아래와 같이 제약조건 구조를 작성한다.
	CONSTRAINT FOREIGN KEY ([`열 이름`, . . . ]) REDERENDES `참조 대상 스키마`.`참조 대상 테이블` ([`참조 대상 열 이름`, . . .])
		[ON DELETE CASCADE]?
		[ON UPDATE CASCADE]?
	*ON DELETE CASCADE : 참조 대상이 삭제되면 현재 레코드도 같이 삭제되게 한다.
	*ON UPDATE CASCADE : 참조 대상이 수정되면 현재 레코드도 같이 수정되게 한다.

체크 제약 조건(Check Constraint)
-체크 제약 조건은 주어진 논리 조건을 만족할 때에만 레코드를 삽입할 수 있게하기 위해 사용
-다른 제약 조건과 달리 반드시 어떠한 열에 의존적이지는 않다.
-체크 제약조건을 선언하려면 아래와 같이 제약 조건을 작성
	CONSTRAINT CHECK ([조건])

-----------------------------------------

조회하기
-특정 스키마에 소속되어 있는 테이블의 목록을 조회하기 위해 아래 쿼리를 실행
	SHOW TABLES IN `소속 스키마 이름`;

-특정 테이블이 가지고 있는 열의 구조를 조회하기 위해 아래 쿼리를 실행
	DESC `스키마 이름`.`테이블 이름`;
	DESCRIBE `스키마 이름`.`테이블 이름`;

-----------------------------------------

수정하기



이름 및 소속 스키마 변경하기
-테이블을 이름을 변경하거나, 소속된 스키마를 변경하고자 할때 아래 쿼리를 실행
	ALTER TABLE `기존 스키마 이름`.`기존 테이블 이름` RENAME `새로운 스키마 이름`.`새로운 테이블 이름`;

	   *소속 스키마 변경 없이 테이블 이름만 변경하고자 한다면 기존 스키마 이름과 새로운  스키마 이름을 동일하게 유지하면 된다.
	   *테이블 이름 변경 없이 소속 스키마만 변경하고자 한다면 기존 테이블 이름과 새로운  테이블 이름을 동일하게 유지하면 된다.


열 추가하기
-존재하는 테이블의 열을 추가하기 위해 아래 쿼리를 실행
	ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조];
	   *별도의 명시가 없다면 추가되는 열을 테이블이 가지는 열들 중에 가장 마지막 자리에 추가
	   *추가하려는 열을 특정 열 뒤에 추가하려면 아래와 같이 AFTER 키워드를 사용 할 수 있다.
	
	ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조] AFTER `대상열 이름`;

	   *별도의 BEFORE 키워드는 없음에 유의하고, 가장 앞자리에 열을 추가하기 위해서는 아래와 같이 FIRST 키워드를 활용
	
	ALTER TABLE `스키마 이름`.`테이블 이름` ADD COLUMN [열 구조] FIRST;


열 이름 변경하기
-테이블이 가지고 있는 열의 이름을 변경하기 위해 아래 쿼리를 실행
	ALTER TABLE `스키마 이름`.`테이블 이름` RENAME COLUMN `기존 열 이름` TO `새로운 열 이름`;


열 구조 변경하기
-테이블이 가지고 있는 열의 구조를 변경하기 위해 아래 쿼리를 실행
	ALTER TABLE `스키마 이름`.`테이블 이름` MODIFY COLUMN [열 구조];
	   *작성하는 열 구조가 포함하는 열의 이름은 존재하는 상태여야한다.
	   *열 구조 수정과 동시에 AFTER 혹은 FIRST 키워드를 사용하여 위치 또한 옮길 수 있다. 단 위치만 옮긴다 하더라도 기존의 열구조를 똑같이 작성해야함에 유의


열 삭제하기
-테이블이 가지고 있는 열을 삭제하기 위해 아래 쿼리를 실행
	ALTER TABLE `스키마 이름`.`테이블 이름` DROP COLUMN `열 이름`;
	   *삭제하는 열에 해당하는 모든 레코드들의 데이터가 삭제되고 되돌릴 수 없음으로 유의한다.


-----------------------------------------

삭제하기
-존재하는 테이블을 삭제하기 위해 아래 쿼리를 실행
	
	DROP TABLE `스키마 이름`.`테이블 이름`;
	   *존재하지 않는 테이블을 삭제 할 수 없음에 유의
	   *테이블을 삭제하면 이가 가지고 있는 레코드가 모두 삭제되고 돌이킬 수 없음에 유의

-----------------------------------------

열
-열 (column)은 테이블에 존재하는 레코드가 가지는 데이터의 타입을 정하기 위해 사용
-명명법: 스네이크 케이스, 단수형 혹은 복수형
-열 구조는 아래와 같다.

	`이름` [데이터 타입] [NULL|NOT NULL]? [DEFAULT x]? [AUTO_INCREMENT]?
	   
	   *NULL : 해당 열의 값이 비어있을 수 있다는 의미. NULL 혹은 NOT NULL을 명시 하지 않을 경우 기본 값
	   *NOT NULL : 해당 열의 값이 비어있을 수 없다는 의미.
	   *DEFAULT x : 레코드 삽입(INSERT)시 해당 열의 값을 명시하지 않을 경우 사용할 기본 값을 x로 설정. 생략시 x는 NULL
	   *AUTO_INCREMENT : 해당 열의 데이터 타입이 숫자고, 기본 키(Primary Key)일때, 레코드 삽입 시 해당 열의 값을 명시하지 않을 경우 해당 열에 마지막으로 사용된 값 (없다면 0)에 1을 더한 값을 사용하도록 한다.

-----------------------------------------

데이터 타입

모든 정수형과 DECIMAL을 제외한 실수형 타입 뒤에 UNSIGNED 키워드를 붙여 음수부 크기 만큼 양수를 추가적으로 사용할 수 있다. 가령 TINYINT UNSIGNED 타입의 범위는 0부터 255 까지이다.

정수형
-TINYINT : (1 Byte) -128 부터 127 까지의 정수
-SMALLINT : (2 Bytes) -32,768 부터 32,767 까지의 정수
-MEDIUMINT : (3 Bytes) -8,388,608 부터 8,388,607 까지의 정수
-INT : (4 Bytes) -2,147,483,648 부터 2,147,483,647 까지의 정수
-BIGINT : (8 Bytes) -9,223,372,036,854,775,808 부터 9,223,372,036,854,775,807 까지의 정수

실수형
-FLOAT : (4 Bytes) -3.482823466E+38 부터 3.482823466E+38 까지의 부동 소수. 표현 가능하다면 약 7자리까지의 정밀도를 가진다.
-DOUBLE : (8 Bytes) -1.797693134862315157E+308 부터 1.79769313486231573E+309까지의 부동 소수. 표현 가능하다면 약 7자리까지의 정밀도를 가진다.
-DECIMAL(t, p) : (t Bytes) 전체 길이가 t, 소수부 길이가 p인 고정 소수. 차지하는 용량이 큰 대신, 값이 유실되지 않는다.
-FLOAT과 DOUBLE은 IEEE 754 표준을 따르는 이진 부동소수점 방식을 사용하는데, 이는 이진수가 아닌 수를 이진수로, 혹은 이진수를 다른 수로 변환하는 과정 중에 수의 손실이 발생하거나 제한된 공간 속에서 표현할 수 없는 값이 있을 수도 있음으로 민감한 데이터를 저장하는데 사용하지 않는다.

문자형
-`VARCHAR(n)`: (최대 `4n` Bytes, `n`은 최대 `65,535`) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. (65,535 Bytes를 초과하지 않는 범위 내에서)
-`TINYTEXT(n)`: (최대 `4n` Bytes, `n`은 최대 `255`) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. (255 Bytes를 초과하지 않는 범위 내에서)
-`TEXT(n)`: (최대 `4n` Bytes, `n`은 최대 `65,535`) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. (65,535 Bytes를 초과하지 않는 범위 내에서)
-`MEDIUMTEXT(n)`: (최대 `4n` Bytes, `n`은 최대 `16,777,215`) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. (16,777,215 Bytes(약 16 메가바이트)를 초과하지 않는 범위 내에서)
-`LONGTEXT(n)`: (최대 `4n` Bytes, `n`은 최대 `4,294,967,295`) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. (4,294,967,295 Bytes(약 4 기가바이트)를 초과하지 않는 범위 내에서)

논리형
-BOOLEAN : (1 Byte) TRUE와 FALSE를 가질 수 있다. 실제 타입은 TYININT(1)이다.

날짜 및 시간
-DATE : 날짜 (년, 월, 일)를 가질 수 있다.
-TIME(n) : 시간 (시, 분, 초)을 가질 수 있다. n은 마이크로초의 길이를 의미하며, 생략시 0이고 최대 값은 6.
-DATETIME(n) : 날짜 및 시간을 가질 수 있다. n은 마이크로초의 길이를 의미하며, 생략시 0이고 최대 값은 6.

기타
