<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        /* 매개 변수로 pieces를 전달 받아 틱택토(Tic Tac Toe) 게임의 승자를 문자열로 반환하는 findWinner 함수를 만드세요. pieces는 이 게임의 말인 'O' 및 'X'의 배치 상황을 가지는 2차원 배열이며 아직 배치되지 않은 인자는 undefined로 정의합니다. 말 판은 반드시 3행 3열이며 그 예시는 아래와 같습니다.
        *
        * 승자가 아직 없는 경우 -> undefined 반환
        * [['O', 'X', 'X']], [['X', 'O', undefined]], [[undefined, 'X', 'X']]
        *
        * 'X'가 승자인 경우 -> 'X' undefined 반환
        * [['X', 'O', 'X']], [['X', 'O', 'O']], [['X', undefined, 'O']] */

        function findWinner(pieces) {
            const size = 3; // 3행 3열의 사이즈임을 정의
            // 행 검사
            for (let row = 0; row < size; row++) {
                const firstCellValue = pieces[row][0]; // 현재 행의 가장 첫번째 칸의 값 정의
                let matchingCount = 0; // 현재 행의 첫번째 칸의 값과 나머지 칸의 값이 일치하는 개수를 담을 변수
                for (let col = 1; col < size; col++) {
                    if (pieces[row][col] !== undefined && pieces[row][col] === firstCellValue) {
                        matchingCount++; // 첫번째 칸의 값과 나머지 칸의 값이 일치하면 1씩 증가
                    }
                }
                if (matchingCount === size - 1) { // 일치하는 칸의 개수가 (사이즈 - 1)(2)과 같으면 승자인 것으로 판정.
                    return firstCellValue;
                }
            }
            // 열 검사
            for (let col = 0; col < size; col++) {
                const firstCellValue = pieces[0][col];
                let matchingCount = 0;
                for (let row = 1; row < size; row++) {
                    if (pieces[row][col] !== undefined && pieces[row][col] === firstCellValue) {
                        matchingCount++;
                    }
                }
                if (matchingCount === size - 1) {
                    return firstCellValue;
                }
            }
            // 대각선 검사(북서-남동 방향)
            if (pieces[0][0] !== undefined) {
                const firstCellValue = pieces[0][0]; // 가장 첫번째 행, 가장 첫번째 칸의 값으로 지정
                let matchingCount = 0;
                for (let i = 1; i < size; i++) { // i는 1부터 (size - 1)(2)까지 증가
                    if (pieces[i][i] === firstCellValue) { // 비교하는 칸의 값과 비교. 이때 칸의 좌표는 (1, 1), (2, 2)로 순차 증가함.
                        matchingCount++;
                    }
                }
                if (matchingCount === size - 1) {
                    return firstCellValue;
                }
            }
            // 대각선 검사(북동-남서 방향)
            if (pieces[0][size - 1] !== undefined) {
                const firstCellValue = pieces[0][size - 1]; // 가장 첫번째 행, 가장 마지막 칸의 값으로 지정. (0, 2)
                let matchingCount = 0;
                for (let i = 1; i < size; i++) { // i는 1부터 (size - 1)(2)까지 증가
                    if (pieces[i][(size - 1) - i] === firstCellValue) { // 비교하는 칸의 값과 비교. 이때 칸의 좌표는 (1, 1), (2, 0)으로, 행은 증가, 열은 감소함.
                        matchingCount++;
                    }
                }
                if (matchingCount === size - 1) {
                    return firstCellValue;
                }
            }
            return undefined; // 행, 열, 각 대각선까지 검사하였는데 return을 만나지 못하였다면 승자가 없는 것으로 판단.
        }

    </script>
</head>
<body>

</body>
</html>